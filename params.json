{"name":"Stem","tagline":"Swift Tensor Engine for Machine-learning","body":"# Swift Tensor Engine for Machine-learning STEM\r\n\r\n## Overview\r\n\r\nSTEM provides an extensible Tensor library for Swift with a primary focus on the development of Machine Learning algorithms.\r\n\r\n\r\n### Why Swift?\r\n\r\nThere are several reasons Swift is a good candidate for writing Machine Learning algorithms:\r\n\r\n1. It's compiled:\r\n\r\n a. None of the overhead normally associated with interpreted languages\r\n b. It's easy to call compiled libraries\r\n\r\n\r\n2. It's simple to use, but has powerful syntax:\r\n\r\n\ta. Operator overloading\r\n\tb. Generics have much of the same power that templates have, but without having to resort to messy template hacking\r\n\r\n3. It's strongly typed:\r\n\r\n\ta. Mistakes can be discovered quickly\r\n\tb. Can dispatch based on argument type\r\n\r\n4. It supports good design\r\n\r\n\ta. Important for writing machine-learning algorithms for real-world problems\r\n\r\n5. Playground provides a very nice method to document algorithms\r\n\r\n\r\n## Design\r\nThe design of *STEM* is to provide a fast and flexible library. Rather than focus on a creating large framework with a million features, the goal is to provide the tools necessary to create those frameworks. Much of the code was inspired by Numpy, Theano, and Torch.\r\n\r\n### Tensors\r\nA `Tensor` is defined as a `Storage` that is tied together with a `StorageView`.The flexibility in STEM comes from the fact that `Storage` is a generic parameter to the `Tensor` class. This allows new types of `Storage` to be defined (e.g. BLAS, GPU, etc.) while still maintaining the same interface by allowing how the data is stored as well as providing a mechanism for dispatching to different methods based on each `Storage` type (e.g. `CBlasStorage` will cause CBlas methods to be called on the `Tensor` operations).\r\n\r\n### Vectors and Matrices\r\nSTEM defines the following types:\r\n\r\n* Vector\r\n* RowVector\r\n* ColumnVector\r\n* Matrix\r\n\r\nEach type is a subclass of `Tensor`, and provide:\r\n\r\n1. Constraints on the `Tensor`s\r\n2. Initializers that use those constraints to simplify construction\r\n3. The correct methods will be called based on the type (e.g. vector*vector could mean dot product or outer product depending on whether they are `RowVectors` or `ColumnVectors`)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}